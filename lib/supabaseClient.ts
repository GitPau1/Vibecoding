
import { createClient } from '@supabase/supabase-js';
import type { Player } from '../types';

// The recursive `Json` type generated by Supabase can cause a "Type instantiation is excessively deep and possibly infinite" error.
// To work around this, we are using 'any' for the jsonb columns. This resolves the compiler error at the cost of type safety for these specific fields.
// The application code uses type assertions (e.g., `v.players as Player[]`) to handle this.

export type Database = {
  public: {
    Tables: {
      articles: {
        Row: {
          id: string
          created_at: string
          title: string
          body: string
          image_url: string | null
          recommendations: number
          views: number
          user_id: string
        }
        Insert: {
          id?: string
          created_at?: string
          title: string
          body: string
          image_url?: string | null
          recommendations?: number
          views?: number
          user_id: string
        }
        Update: {
          id?: string
          created_at?: string
          title?: string
          body?: string
          image_url?: string | null
          recommendations?: number
          views?: number
          user_id?: string
        }
      }
      bug_reports: {
        Row: {
          id: string
          created_at: string
          title: string
          description: string
          url: string
          screenshot_url: string | null
        }
        Insert: {
          id?: string
          created_at?: string
          title: string
          description: string
          url: string
          screenshot_url?: string | null
        }
        Update: {
          id?: string
          created_at?: string
          title?: string
          description?: string
          url?: string
          screenshot_url?: string | null
        }
      }
      profiles: {
        Row: {
          id: string
          updated_at: string | null
          username: string
          nickname: string
        }
        Insert: {
          id: string
          updated_at?: string | null
          username: string
          nickname: string
        }
        Update: {
          id?: string
          updated_at?: string | null
          username?: string
          nickname?: string
        }
      }
      squad_players: {
        Row: {
          id: string
          created_at: string
          name: string
          number: number
          position: string
          photo_url: string | null
        }
        Insert: {
          id?: string
          created_at?: string
          name: string
          number: number
          position: string
          photo_url?: string | null
        }
        Update: {
          id?: string
          created_at?: string
          name?: string
          number?: number
          position?: string
          photo_url?: string | null
        }
      }
      user_votes: {
        Row: {
          id: string
          created_at: string
          vote_id: string
          user_id: string
          vote_value: string
        }
        Insert: {
          id?: string
          created_at?: string
          vote_id: string
          user_id: string
          vote_value: string
        }
        Update: {
          id?: string
          created_at?: string
          vote_id?: string
          user_id?: string
          vote_value?: string
        }
      }
      vote_options: {
        Row: {
          created_at: string
          id: string
          label: string
          vote_id: string
          votes: number
        }
        Insert: {
          created_at?: string
          id?: string
          label: string
          vote_id: string
          votes?: number
        }
        Update: {
          created_at?: string
          id?: string
          label?: string
          vote_id?: string
          votes?: number
        }
      }
      votes: {
        Row: {
          created_at: string
          description: string | null
          end_date: string
          id: string
          image_url: string | null
          team_a: string | null
          team_b: string | null
          title: string
          type: string
          user_id: string
          final_score: string | null
          players: Player[] | null
        }
        Insert: {
          created_at?: string
          description?: string | null
          end_date: string
          id?: string
          image_url?: string | null
          team_a?: string | null
          team_b?: string | null
          title: string
          type: string
          user_id: string
          final_score?: string | null
          players?: Player[] | null
        }
        Update: {
          created_at?: string
          description?: string | null
          end_date?: string
          id?: string
          image_url?: string | null
          team_a?: string | null
          team_b?: string | null
          title?: string
          type?: string
          user_id?: string
          final_score?: string | null
          players?: Player[] | null
        }
      }
      x_posts: {
        Row: {
          id: string
          created_at: string
          description: string
          post_url: string
          user_id: string
        }
        Insert: {
          id?: string
          created_at?: string
          description: string
          post_url: string
          user_id: string
        }
        Update: {
          id?: string
          created_at?: string
          description?: string
          post_url?: string
          user_id?: string
        }
      }
      player_ratings: {
          Row: {
              id: string
              created_at: string
              title: string
              description: string | null
              image_url: string | null
              end_date: string
              players: Player[] | null
              user_id: string
          }
          Insert: {
              id?: string
              created_at?: string
              title: string
              description?: string | null
              image_url?: string | null
              end_date: string
              players?: Player[] | null
              user_id: string
          }
          Update: {
              id?: string
              created_at?: string
              title?: string
              description?: string | null
              image_url?: string | null
              end_date?: string
              players?: Player[] | null
              user_id?: string
          }
      }
      player_rating_submissions: {
          Row: {
              id: string
              created_at: string
              rating_id: string
              user_id: string
              player_id: number
              rating: number
              comment: string | null
          }
          Insert: {
              id?: string
              created_at?: string
              rating_id: string
              user_id: string
              player_id: number
              rating: number
              comment?: string | null
          }
          Update: {
              id?: string
              created_at?: string
              rating_id?: string
              user_id?: string
              player_id?: number
              rating?: number
              comment?: string | null
          }
      }
    }
    Views: {
      player_rating_stats: {
        Row: {
          rating_id: string | null;
          player_id: number | null;
          player_name: string | null;
          average_rating: number | null;
          rating_count: number | null;
          comments: string[] | null;
        }
      }
    }
    Functions: {
      increment_recommendation: {
        Args: {
          article_id_to_inc: string
        }
        Returns: undefined
      }
      increment_article_view: {
        Args: {
          article_id_to_inc: string
        }
        Returns: undefined
      }
      increment_vote: {
        Args: {
          option_id_to_inc: string
        }
        Returns: undefined
      }
      handle_score_vote: {
        Args: {
          vote_id_in: string,
          score_label: string
        }
        Returns: undefined
      },
      cast_or_update_score_vote: {
        Args: {
          vote_id_in: string,
          user_id_in: string,
          score_label_in: string
        }
        Returns: undefined
      }
      enter_match_result: {
        Args: {
          vote_id_in: string,
          final_score_in: string
        }
        Returns: undefined
      }
    }
    Enums: {
      [_ in never]: never
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}

// This application uses Vite, a modern build tool for web development.
// For client-side applications built with Vite, environment variables must be
// prefixed with `VITE_` to be exposed to the browser for security reasons.
// This is different from Create React App which uses `REACT_APP_`.
//
// When deploying to Vercel, you must set these environment variables in your
// Vercel project's settings. Make sure they are also prefixed with `VITE_`.
//
// For local development, create a `.env` file in the project's root directory with:
// VITE_SUPABASE_URL=your-supabase-url
// VITE_SUPABASE_ANON_KEY=your-supabase-anon-key

// Safely access environment variables to prevent crashes when `import.meta.env` is undefined.
// This can happen in environments that do not use Vite or a similar build tool.
const supabaseUrl = (import.meta as any).env?.VITE_SUPABASE_URL;
const supabaseAnonKey = (import.meta as any).env?.VITE_SUPABASE_ANON_KEY;


// We initialize the client, but it will be null if the environment variables are missing.
// The main App component will handle this case and display a message to the user.
export const supabase = (supabaseUrl && supabaseAnonKey)
  ? createClient<Database>(supabaseUrl, supabaseAnonKey)
  : null;

if (!supabase) {
  console.warn("Supabase configuration is missing. The app will display an error message. Please set VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY in your environment.");
}

/*
-- REQUIRED SUPABASE SQL SETUP --
-- Run these queries in your Supabase project's SQL Editor.
-- Note: Supabase client libraries use parameterized queries, which protects against SQL Injection.

-- 0. Make sure to DISABLE "Confirm email" in Supabase Auth settings for username login to work smoothly.
-- Go to Authentication -> Providers -> Email and turn off "Confirm email".

-- 1. Create Tables:
-- Note: Enable RLS (Row Level Security) for all tables and define policies.

-- PROFILES TABLE (for user data)
CREATE TABLE public.profiles (
  id uuid REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL PRIMARY KEY,
  updated_at timestamp with time zone,
  username text UNIQUE NOT NULL,
  nickname text NOT NULL,
  
  CONSTRAINT username_length CHECK (char_length(username) >= 3 AND char_length(username) <= 20),
  CONSTRAINT nickname_length CHECK (char_length(nickname) >= 2 AND char_length(nickname) <= 20)
);
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update their own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);


-- ARTICLES TABLE
CREATE TABLE public.articles (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at timestamp with time zone DEFAULT now() NOT NULL,
  title text NOT NULL,
  body text NOT NULL,
  image_url text,
  recommendations integer DEFAULT 0 NOT NULL,
  views integer DEFAULT 0 NOT NULL,
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE
);
ALTER TABLE public.articles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow public read access on articles" ON public.articles FOR SELECT USING (true);
CREATE POLICY "Allow authenticated users to insert articles" ON public.articles FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Allow authors to update their own articles" ON public.articles FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Allow authors to delete their own articles" ON public.articles FOR DELETE TO authenticated USING (auth.uid() = user_id);


-- VOTES TABLE (Player Ratings are now separate)
CREATE TABLE public.votes (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at timestamp with time zone DEFAULT now() NOT NULL,
  title text NOT NULL,
  description text,
  type text NOT NULL, -- Enum: '경기 결과 예측', '베스트 플레이어', '찬반 투표'
  image_url text,
  end_date text NOT NULL,
  players jsonb,
  team_a text,
  team_b text,
  final_score text, -- For MATCH type to store final result
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE
);
ALTER TABLE public.votes ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow public read access on votes" ON public.votes FOR SELECT USING (true);
CREATE POLICY "Allow authenticated users to insert votes" ON public.votes FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Allow authors to update their own votes" ON public.votes FOR UPDATE TO authenticated USING (auth.uid() = user_id);


-- VOTE OPTIONS TABLE
CREATE TABLE public.vote_options (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at timestamp with time zone DEFAULT now() NOT NULL,
  vote_id uuid REFERENCES votes(id) ON DELETE CASCADE NOT NULL,
  label text NOT NULL,
  votes numeric DEFAULT 0 NOT NULL
);
ALTER TABLE public.vote_options ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow public read access on vote_options" ON public.vote_options FOR SELECT USING (true);
CREATE POLICY "Allow authenticated users to insert vote options" ON public.vote_options FOR INSERT TO authenticated WITH CHECK (true);
CREATE POLICY "Allow authenticated users to update vote options" ON public.vote_options FOR UPDATE TO authenticated USING (true);


-- USER VOTES TABLE (for tracking individual votes, especially for match scores)
CREATE TABLE public.user_votes (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    vote_id uuid NOT NULL REFERENCES public.votes(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    vote_value text NOT NULL,
    UNIQUE (vote_id, user_id)
);
ALTER TABLE public.user_votes ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow public read access to find winners" ON public.user_votes FOR SELECT USING (true);
CREATE POLICY "Users can manage their own votes" ON public.user_votes FOR ALL USING (auth.uid() = user_id);


-- PLAYER RATINGS TABLE (New)
CREATE TABLE public.player_ratings (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at timestamp with time zone DEFAULT now() NOT NULL,
  title text NOT NULL,
  description text,
  image_url text,
  end_date text NOT NULL,
  players jsonb, -- Stores player list for this rating event
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE
);
ALTER TABLE public.player_ratings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow public read access on player_ratings" ON public.player_ratings FOR SELECT USING (true);
CREATE POLICY "Allow authenticated users to insert player_ratings" ON public.player_ratings FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);

-- PLAYER RATING SUBMISSIONS TABLE (New)
CREATE TABLE public.player_rating_submissions (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    rating_id uuid NOT NULL REFERENCES public.player_ratings(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    player_id integer NOT NULL,
    rating numeric NOT NULL,
    comment text,
    UNIQUE(rating_id, user_id, player_id)
);
ALTER TABLE public.player_rating_submissions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow public read access" ON public.player_rating_submissions FOR SELECT USING (true);
CREATE POLICY "Users can manage their own submissions" ON public.player_rating_submissions FOR ALL USING (auth.uid() = user_id);


-- X_POSTS TABLE
CREATE TABLE public.x_posts (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at timestamp with time zone DEFAULT now() NOT NULL,
  description text NOT NULL,
  post_url text NOT NULL,
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE
);
ALTER TABLE public.x_posts ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow public read access on x_posts" ON public.x_posts FOR SELECT USING (true);
CREATE POLICY "Allow authenticated users to insert x_posts" ON public.x_posts FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Allow authors to update their own x_posts" ON public.x_posts FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Allow authors to delete their own x_posts" ON public.x_posts FOR DELETE TO authenticated USING (auth.uid() = user_id);


-- BUG REPORTS TABLE
CREATE TABLE public.bug_reports (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at timestamp with time zone DEFAULT now() NOT NULL,
  title text NOT NULL,
  description text NOT NULL,
  url text NOT NULL,
  screenshot_url text
);
ALTER TABLE public.bug_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow anon insert on bug_reports" ON public.bug_reports FOR INSERT WITH CHECK (true);
CREATE POLICY "Allow authenticated read on bug_reports" ON public.bug_reports FOR SELECT TO authenticated USING (true);


-- SQUAD PLAYERS TABLE
CREATE TABLE public.squad_players (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at timestamp with time zone DEFAULT now() NOT NULL,
  name text NOT NULL,
  "number" integer NOT NULL,
  position text NOT NULL, -- e.g. '골키퍼', '수비수', '미드필더', '공격수'
  photo_url text
);
ALTER TABLE public.squad_players ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow public read access on squad_players" ON public.squad_players FOR SELECT USING (true);
CREATE POLICY "Allow authenticated users to manage squad_players" ON public.squad_players FOR ALL TO authenticated USING (true);


-- 2. Create Views and Functions:

-- PLAYER RATING STATS VIEW (New)
CREATE OR REPLACE VIEW public.player_rating_stats AS
SELECT
    s.rating_id,
    p.id as player_id,
    p.name as player_name,
    avg(s.rating) as average_rating,
    count(s.id) as rating_count,
    jsonb_agg(s.comment) FILTER (WHERE s.comment IS NOT NULL AND s.comment <> '') as comments
FROM 
    public.player_rating_submissions s
JOIN 
    public.player_ratings pr ON s.rating_id = pr.id
JOIN
    jsonb_to_recordset(pr.players) as p(id int, name text) ON p.id = s.player_id
GROUP BY 
    s.rating_id, p.id, p.name;


-- RPC FUNCTIONS
CREATE OR REPLACE FUNCTION increment_vote(option_id_to_inc uuid)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  UPDATE public.vote_options SET votes = votes + 1 WHERE id = option_id_to_inc;
END;
$$;

CREATE OR REPLACE FUNCTION increment_recommendation(article_id_to_inc uuid)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  UPDATE public.articles SET recommendations = recommendations + 1 WHERE id = article_id_to_inc;
END;
$$;

CREATE OR REPLACE FUNCTION increment_article_view(article_id_to_inc uuid)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  UPDATE public.articles SET views = views + 1 WHERE id = article_id_to_inc;
END;
$$;

CREATE OR REPLACE FUNCTION handle_score_vote(vote_id_in uuid, score_label text)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  option_id_found uuid;
BEGIN
  SELECT id INTO option_id_found
  FROM public.vote_options
  WHERE vote_id = vote_id_in AND label = score_label;
  IF option_id_found IS NOT NULL THEN
    UPDATE public.vote_options SET votes = votes + 1 WHERE id = option_id_found;
  ELSE
    INSERT INTO public.vote_options (vote_id, label, votes) VALUES (vote_id_in, score_label, 1);
  END IF;
END;
$$;


CREATE OR REPLACE FUNCTION cast_or_update_score_vote(vote_id_in uuid, user_id_in uuid, score_label_in text)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  old_vote_value text;
BEGIN
  SELECT vote_value INTO old_vote_value FROM public.user_votes WHERE vote_id = vote_id_in AND user_id = user_id_in;

  IF old_vote_value IS NOT NULL AND old_vote_value != score_label_in THEN
    UPDATE public.vote_options SET votes = votes - 1 WHERE vote_id = vote_id_in AND label = old_vote_value AND votes > 0;
  END IF;

  INSERT INTO public.user_votes (vote_id, user_id, vote_value)
  VALUES (vote_id_in, user_id_in, score_label_in)
  ON CONFLICT (vote_id, user_id) DO UPDATE SET vote_value = EXCLUDED.vote_value;

  IF old_vote_value IS NULL OR old_vote_value != score_label_in THEN
    PERFORM handle_score_vote(vote_id_in, score_label_in);
  END IF;
END;
$$;


CREATE OR REPLACE FUNCTION enter_match_result(vote_id_in uuid, final_score_in text)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  UPDATE public.votes
  SET 
    final_score = final_score_in,
    end_date = now()::text
  WHERE id = vote_id_in;
END;
$$;


-- 3. Set up trigger to automatically create a profile for new users from metadata
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id, username, nickname)
  VALUES (new.id, new.raw_user_meta_data->>'username', new.raw_user_meta_data->>'nickname');
  RETURN new;
END;
$$;

CREATE OR REPLACE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

*/